# C++基础



## 菱形继承 

## 模板

## extern

## static


# 字符串


# 散列表

## 计算
假设有一个列表[(G1, X1), (G2, X2),(G3, X3),… ], G是连续的， 实现一个函数，返回[n1, n2, …],  n 是 X在该组G中的出现次数。
例如：
输入：[(1, 'A'), (1, 'B'), (1, 'A'), (1, 'A'),(2, 'AB'),(2, 'AB'),(2, 'A'),(2, 'AC'),(2, 'A')]
输出：[1, 1, 2, 3, 1, 2, 1, 1, 2]

问题一：
用C++编写程序，解决上述问题。
```C++
using Data = std::vector<std::pair<std::string, std::string>>;

using Order = std::vector<size_t>;

Order calcOrder(const Data & data)
{
    Order o;
        
    return o;
}

void printOrder(const Order & order)
{
    for (auto & item : order) {
        std::cout << item << ", ";
    }
}

int main(int argc, const char * argv[]) {
    Data d { {"Group1", "A"}, {"Group1", "AB"}, {"Group1", "AB"}, {"Group1", "A"}, {"Group1", "C"}, {"Group1", "A"},
        {"Group2", "AB"}, {"Group2", "AC"}, {"Group2", "AB"}, {"Group2", "A"}, {"Group2", "AC"},
        {"Group3", "B"}, {"Group3", "B"}, {"Group3", "B"}, {"Group2", "A"}, {"Group2", "C"},
    };

    // 期望输出结果：
    // 1, 1, 2, 2, 1, 3,
    // 1, 1, 2, 1, 2,
    // 1, 2, 3, 1, 1,
    printOrder(calcOrder(d));
    
    return 0;
}

```


问题二：
当我们要实时处理大量的数据（例如十亿条数据），数据的特点是每个group包含的数据项的数量都在50以内。考虑如何改进算法及数据结构，以更高效地处理。


# 线性表

# 递归


# 动态规划

# 分治

# 其他
